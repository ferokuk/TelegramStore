from redis.asyncio.client import Redis
import json
from functools import wraps
from typing import Callable, Any, Coroutine

from src.logger import logger

REDIS_URL = "redis://redis:6379/0"

# Глобальный пул соединений
redis_client: None | Redis = None


async def init_redis():
    """Инициализация клиента Redis"""
    global redis_client
    if redis_client is None:
        redis_client = Redis(
            host="redis",
            port=6379,
            socket_connect_timeout=5,
            socket_keepalive=True,
            decode_responses=True
        )
        await redis_client.ping()
    return redis_client


def cache(key_pattern: str, ttl_seconds: int = 3600):
    """
    Декоратор для кеширования результатов асинхронных функций.
    :param key_pattern: Шаблон ключа (может содержать `{args}` и `{kwargs}`)
    :param ttl_seconds: Время жизни кеша в секундах
    """

    def decorator(func: Callable[..., Coroutine[Any, Any, Any]]):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            client = await init_redis()

            # Формируем ключ, подставляя аргументы
            key = key_pattern.format(*args, **kwargs)

            # Пытаемся получить данные из кеша
            cached_data = await client.get(key)
            logger.log(f"{key=}, {cached_data=}")
            if cached_data is not None:
                return json.loads(cached_data)

            # Если нет в кеше, вызываем функцию
            result = await func(*args, **kwargs)

            # Сохраняем результат в кеш
            try:
                await client.setex(key, ttl_seconds, json.dumps(result))
            except TypeError:
                # Для не-JSON-сериализуемых объектов
                await client.setex(key, ttl_seconds, str(result))
            return result

        return wrapper

    return decorator


async def invalidate_cache(key_pattern: str):
    """Инвалидация кеша по шаблону ключа с использованием SCAN"""
    client = await init_redis()

    keys = []
    async for key in client.scan_iter(match=key_pattern, count=1000):
        keys.append(key)

    if keys:
        await client.delete(*keys)


async def close_redis():
    """Закрытие соединения с Redis"""
    global redis_client
    if redis_client:
        await redis_client.close()
        redis_client = None
